#!/usr/bin/env bash
# skill-hub - Centralized skill management for multi-agent distribution
#
# Data directory: ~/.skill-hub/ (or $SKILL_HUB_DATA)
# This script manages symlinks to distribute skills to AI agents

set -e

# Data directory - can be overridden with SKILL_HUB_DATA env var
SKILL_HUB_DATA="${SKILL_HUB_DATA:-$HOME/.skill-hub}"
SKILLS_DIR="$SKILL_HUB_DATA/skills"
AGENTS_FILE="$SKILL_HUB_DATA/agents.conf"
PRESETS_FILE="$SKILL_HUB_DATA/presets.conf"
CONFIG_SETTINGS="$SKILL_HUB_DATA/settings.conf"
DISCOVERY_DONE=false

# For backwards compatibility during migration
SKILL_HUB="$SKILLS_DIR"
CONFIG_FILE="$AGENTS_FILE"

usage() {
    cat <<EOF
skill-hub - Centralized skill management

Usage: skill-hub [command] [options]

Running 'skill-hub' with no command launches the interactive menu (requires gum).

Commands:
    init                Initialize ~/.skill-hub/ data directory
    new <name>          Create a new skill from template
    status              Show current skill distribution status
    i, interactive      Interactive menu (requires gum)
    list                List all skills
    info <skill>        Show detailed info about a skill
    discover            Discover agent workspaces (updates agents.conf)
    sync [agent]        Apply config to filesystem (create/update symlinks)
    uninstall [agent]   Detach agents from the hub (copy skills locally; untested)
    path                Print data directory path

    set <agent> <skills>
                        Set skills for agent ("all" or comma-separated)
    enable <agent> <skill>
                        Add a skill to an agent
    disable <agent> <skill>
                        Remove a skill from an agent
    copy <from> <to>    Copy skills from one agent to another
    reset <agent>       Reset agent to all skills
    move-skill <skill> <from-agent> <to-agent>
                        Move a skill between agents

    add-agent <name> <path> [skills]
                        Add agent target (skills: "all" or comma-separated)
    link-project <skill> <project-path>
                        Link a skill to a project repo
    migrate <skill> [path]
                        Move skill to project repo (default: \$PROJECT_DIR/<skill>)

    local <agent>       List local (non-symlinked) skills in agent workspace
    adopt <agent> <skill>
                        Import a skill from agent workspace into skill-hub

    preset create <name> <skills>
                        Create a preset skill bundle
    preset list         List all presets
    preset show <name>  Show skills in a preset
    preset apply <agent> <preset>
                        Apply preset to an agent
    preset delete <name>
                        Delete a preset

    deps [install]      Check/install skill dependencies
    config [key] [value]
                        Get/set configuration (project_dir, git_init)

Data directory: $SKILL_HUB_DATA
EOF
}

#================================================================================
# Init & Setup
#================================================================================

# Get a setting value
get_setting() {
    local key=$1
    local default=$2
    if [ -f "$CONFIG_SETTINGS" ]; then
        local value=$(grep "^$key=" "$CONFIG_SETTINGS" 2>/dev/null | cut -d= -f2-)
        [ -n "$value" ] && echo "$value" && return 0
    fi
    echo "$default"
}

# Set a setting value
set_setting() {
    local key=$1
    local value=$2
    mkdir -p "$(dirname "$CONFIG_SETTINGS")"
    touch "$CONFIG_SETTINGS"

    if grep -q "^$key=" "$CONFIG_SETTINGS" 2>/dev/null; then
        local tmp=$(mktemp)
        sed "s|^$key=.*|$key=$value|" "$CONFIG_SETTINGS" > "$tmp"
        mv "$tmp" "$CONFIG_SETTINGS"
    else
        echo "$key=$value" >> "$CONFIG_SETTINGS"
    fi
}

# Show or modify config
config_cmd() {
    local key=$1
    local value=$2

    if [ -z "$key" ]; then
        echo "Current configuration:"
        echo ""
        if [ -f "$CONFIG_SETTINGS" ]; then
            cat "$CONFIG_SETTINGS"
        else
            echo "(no settings configured)"
        fi
        echo ""
        echo "Available settings:"
        echo "  project_dir   Default directory for project repos (e.g., ~/p)"
        echo "  git_init      Auto-initialize git in migrated repos (true/false)"
        return 0
    fi

    if [ -z "$value" ]; then
        local current=$(get_setting "$key" "")
        if [ -n "$current" ]; then
            echo "$key=$current"
        else
            echo "$key is not set"
        fi
        return 0
    fi

    set_setting "$key" "$value"
    echo "Set $key=$value"
}

find_clawdbot_config() {
    local configured="${SKILL_HUB_CLAWDBOT_CONFIG:-}"
    if [ -n "$configured" ] && [ -f "$configured" ]; then
        echo "$configured"
        return 0
    fi

    local candidates=(
        "$HOME/.clawdbot/config/clawdbot.json"
        "$HOME/.clawdbot/clawdbot.json"
    )

    local project_dir=$(get_setting "project_dir" "")
    if [ -n "$project_dir" ]; then
        candidates+=(
            "$project_dir/clawd-workspace/config/clawdbot.json"
            "$project_dir/clawd/config/clawdbot.json"
            "$project_dir/clawdbot/config/clawdbot.json"
        )
    fi

    local candidate=""
    for candidate in "${candidates[@]}"; do
        if [ -f "$candidate" ]; then
            echo "$candidate"
            return 0
        fi
    done

    if [ -n "$project_dir" ] && command -v find &>/dev/null; then
        local found
        found=$(find "$project_dir" -maxdepth 4 -type f -path "*/config/clawdbot.json" -print -quit 2>/dev/null)
        [ -n "$found" ] && echo "$found" && return 0
    fi

    return 1
}

discover_clawdbot_agents() {
    local config_path=$1
    [ -z "$config_path" ] && return 0

    if ! command -v python3 &>/dev/null; then
        echo "WARN: python3 not found; skipping clawdbot agent discovery" >&2
        return 0
    fi

    python3 - "$config_path" <<'PY'
import json
import os
import sys

path = sys.argv[1]
try:
    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)
except Exception:
    sys.exit(0)

agents = data.get("agents", {})
defaults = agents.get("defaults", {})
default_workspace = defaults.get("workspace")
seen = set()

for entry in agents.get("list", []) or []:
    agent_id = entry.get("id") or entry.get("name")
    if not agent_id:
        continue
    workspace = entry.get("workspace") or default_workspace
    if not workspace:
        continue
    workspace = os.path.expanduser(workspace)
    if not os.path.isabs(workspace):
        workspace = os.path.abspath(os.path.join(os.path.dirname(path), workspace))
    name = f"clawdbot-{agent_id}"
    if name in seen:
        continue
    seen.add(name)
    print(f"{name}:{workspace}/skills")
PY
}

discover_agents() {
    [ "$DISCOVERY_DONE" = true ] && return 0
    DISCOVERY_DONE=true

    local config_path
    config_path=$(find_clawdbot_config) || return 0

    local discovered
    discovered=$(discover_clawdbot_agents "$config_path") || return 0
    [ -z "$discovered" ] && return 0

    mkdir -p "$(dirname "$CONFIG_FILE")"
    touch "$CONFIG_FILE"

    local added=0
    local updated=0
    while IFS= read -r line; do
        [ -z "$line" ] && continue
        IFS=: read -r name path <<< "$line"
        path="${path/#\~/$HOME}"

        # Check if agent already exists
        local existing_line
        existing_line=$(grep "^${name}:" "$CONFIG_FILE" 2>/dev/null) || true

        if [ -n "$existing_line" ]; then
            # Agent exists - check if path changed
            local existing_path
            existing_path=$(echo "$existing_line" | cut -d: -f2)
            existing_path="${existing_path/#\~/$HOME}"

            if [ "$existing_path" != "$path" ]; then
                # Path changed - update it, preserving skills
                local existing_skills
                existing_skills=$(echo "$existing_line" | cut -d: -f3-)
                existing_skills="${existing_skills:-all}"

                local tmp=$(mktemp)
                grep -v "^${name}:" "$CONFIG_FILE" > "$tmp"
                mv "$tmp" "$CONFIG_FILE"
                echo "${name}:${path}:${existing_skills}" >> "$CONFIG_FILE"
                echo "Updated $name path: $existing_path -> $path"
                updated=$((updated + 1))
            fi
            continue
        fi

        # New agent - add it
        if [ "$added" -eq 0 ] && [ "$updated" -eq 0 ]; then
            echo "" >> "$CONFIG_FILE"
            echo "# Discovered from clawdbot.json ($config_path)" >> "$CONFIG_FILE"
        fi
        echo "${name}:${path}:all" >> "$CONFIG_FILE"
        added=$((added + 1))
    done <<< "$discovered"

    if [ "$added" -gt 0 ]; then
        echo "Discovered $added clawdbot agent(s) from $config_path"
    fi
}

init_skill_hub() {
    if [ -d "$SKILL_HUB_DATA" ]; then
        echo "Data directory already exists: $SKILL_HUB_DATA"
        echo ""
        echo "Contents:"
        ls -la "$SKILL_HUB_DATA"
        return 0
    fi

    echo "Creating skill-hub data directory..."
    mkdir -p "$SKILLS_DIR"

    # Create default agents config
    cat > "$AGENTS_FILE" <<'AGENTS'
# Skill Hub Agent Configuration
# Format: name:path:skills
# - name: identifier for the agent
# - path: where skills should be symlinked
# - skills: "all" or comma-separated list

claude-code:~/.claude/skills:all
# codex:~/.codex/skills:all
# clawdbot:~/.clawdbot/skills:all
AGENTS

    echo "Created $SKILL_HUB_DATA"
    echo ""

    # Ask about git/GitHub setup
    local setup_git=false
    local setup_github=false

    if command -v gum &>/dev/null; then
        if gum confirm "Initialize git repo for version control?"; then
            setup_git=true
            if command -v gh &>/dev/null && gum confirm "Push to GitHub as a private repo?"; then
                setup_github=true
            fi
        fi
    else
        echo -n "Initialize git repo for version control? [y/N] "
        read -r answer
        if [[ "$answer" =~ ^[Yy] ]]; then
            setup_git=true
            if command -v gh &>/dev/null; then
                echo -n "Push to GitHub as a private repo? [y/N] "
                read -r answer
                [[ "$answer" =~ ^[Yy] ]] && setup_github=true
            fi
        fi
    fi

    if [ "$setup_git" = true ]; then
        cd "$SKILL_HUB_DATA"
        git init -q
        git add -A
        git commit -q -m "Initial commit: skill-hub setup"
        echo "Initialized git repo"

        if [ "$setup_github" = true ]; then
            local repo_name="agent-skills"
            if command -v gum &>/dev/null; then
                repo_name=$(gum input --placeholder "agent-skills" --value "agent-skills" --header "Repo name:")
            else
                echo -n "Repo name [agent-skills]: "
                read -r input
                [ -n "$input" ] && repo_name="$input"
            fi

            if gh repo create "$repo_name" --private --source=. --push 2>/dev/null; then
                echo "Pushed to GitHub: https://github.com/$(gh api user -q .login)/$repo_name (private)"
            else
                echo "Failed to create GitHub repo. You can do it later with:"
                echo "  cd $SKILL_HUB_DATA && gh repo create $repo_name --private --source=. --push"
            fi
        fi
    fi

    # Ask about project directory for skill migration
    echo ""
    local project_dir=""
    if command -v gum &>/dev/null; then
        if gum confirm "Configure a default project directory for skill migration?"; then
            project_dir=$(gum input --placeholder "~/p" --value "$HOME/p" --header "Project directory (where skill repos will be created):")
        fi
    else
        echo -n "Configure a default project directory for skill migration? [y/N] "
        read -r answer
        if [[ "$answer" =~ ^[Yy] ]]; then
            echo -n "Project directory [~/p]: "
            read -r input
            project_dir="${input:-$HOME/p}"
        fi
    fi

    if [ -n "$project_dir" ]; then
        # Expand ~ if present
        project_dir="${project_dir/#\~/$HOME}"
        set_setting "project_dir" "$project_dir"
        set_setting "git_init" "true"
        echo "Set project_dir=$project_dir"
        echo "Set git_init=true"
    fi

    echo ""
    echo "Next steps:"
    echo "  1. Create a skill:  skill-hub new my-first-skill"
    echo "  2. Edit agents.conf to configure your agents"
    echo "  3. Sync skills:     skill-hub sync"
    if [ -n "$project_dir" ]; then
        echo ""
        echo "To move a skill to its own repo:"
        echo "  skill-hub migrate <skill-name>"
    fi
}

new_skill() {
    local name=$1

    if [ -z "$name" ]; then
        echo "Usage: skill-hub new <skill-name>"
        return 1
    fi

    # Ensure data directory exists
    if [ ! -d "$SKILLS_DIR" ]; then
        echo "Data directory not found. Run 'skill-hub init' first."
        return 1
    fi

    local skill_dir="$SKILLS_DIR/$name"

    if [ -d "$skill_dir" ]; then
        echo "Skill '$name' already exists at $skill_dir"
        return 1
    fi

    mkdir -p "$skill_dir"

    cat > "$skill_dir/SKILL.md" <<SKILL
---
name: $name
description: Brief description of what this skill does
allowed-tools: Bash, Read, Write, Edit, Glob, Grep
---

# $name

Instructions for the AI agent go here.

## Usage

Describe how to use this skill.

## Examples

\`\`\`bash
# Example commands or code
\`\`\`
SKILL

    echo "Created skill: $skill_dir/SKILL.md"
    echo ""
    echo "Edit the SKILL.md file to add your skill instructions."
    echo "Then run 'skill-hub sync' to distribute to agents."
}

print_path() {
    echo "$SKILL_HUB_DATA"
}

get_all_skills() {
    for skill_dir in "$SKILL_HUB"/*/; do
        [ -d "$skill_dir" ] || continue
        skill=$(basename "$skill_dir")
        [[ "$skill" == .* ]] && continue
        echo "$skill"
    done
}

strip_ansi() {
    sed -E 's/\x1b\\[[0-9;]*m//g'
}

label_to_skill() {
    local label=$1
    local clean
    clean=$(printf '%s' "$label" | strip_ansi)
    clean="${clean% (upstream -> clawdbot)}"
    echo "$clean" | sed 's/^ *//; s/ *$//'
}

list_has_line() {
    local list=$1
    local item=$2
    printf '%s\n' "$list" | grep -Fqx "$item"
}

unique_lines() {
    awk '!seen[$0]++'
}

skills_csv_to_lines() {
    echo "$1" | tr ',' '\n' | sed 's/^ *//; s/ *$//' | sed '/^$/d'
}

skills_to_lines() {
    local skills=$1
    if [ "$skills" = "all" ]; then
        get_all_skills
    else
        skills_csv_to_lines "$skills"
    fi
}

is_clawdbot_subagent() {
    [[ "$1" == clawdbot-* ]] && [ "$1" != "clawdbot" ]
}

get_upstream_skills() {
    local agent=$1
    if ! is_clawdbot_subagent "$agent"; then
        return 0
    fi

    local upstream
    upstream=$(get_agent_skills "clawdbot" 2>/dev/null || true)
    [ -z "$upstream" ] && return 0

    # TODO: Extend inherited-skill handling to claude-code/codex project agents in a future release.
    skills_to_lines "$upstream"
}

filter_skills_excluding() {
    local all_skills=$1
    local exclude_skills=$2

    if [ -z "$exclude_skills" ]; then
        printf '%s\n' "$all_skills"
        return 0
    fi

    while IFS= read -r skill; do
        [ -z "$skill" ] && continue
        if ! printf '%s\n' "$exclude_skills" | grep -Fqx "$skill"; then
            echo "$skill"
        fi
    done <<< "$all_skills"
}

lines_to_csv() {
    printf '%s\n' "$1" | sed '/^$/d' | tr '\n' ',' | sed 's/,$//'
}

remove_skill_from_lines() {
    local list=$1
    local skill=$2
    printf '%s\n' "$list" | grep -Fvx "$skill"
}

add_skill_to_lines() {
    local list=$1
    local skill=$2
    if list_has_line "$list" "$skill"; then
        printf '%s\n' "$list"
        return 0
    fi
    if [ -z "$list" ]; then
        echo "$skill"
    else
        printf '%s\n%s\n' "$list" "$skill"
    fi
}

list_skills() {
    echo "Skills in hub ($SKILL_HUB):"
    echo ""

    local central_count=0
    local linked_count=0

    for skill_dir in "$SKILL_HUB"/*/; do
        [ -d "$skill_dir" ] || continue
        skill=$(basename "$skill_dir")
        [[ "$skill" == .* ]] && continue

        if [ -L "${skill_dir%/}" ]; then
            target=$(readlink "${skill_dir%/}")
            printf "  %-25s -> %s\n" "$skill" "$target"
            ((linked_count++))
        else
            printf "  %-25s [central]\n" "$skill"
            ((central_count++))
        fi
    done

    echo ""
    echo "Total: $((central_count + linked_count)) skills ($central_count central, $linked_count project-linked)"
}

parse_config_line() {
    local line=$1
    # Skip comments and empty lines
    [[ "$line" =~ ^[[:space:]]*# ]] && return 1
    [[ -z "${line// }" ]] && return 1

    # Parse name:path:skills (skills defaults to "all")
    IFS=: read -r name path skills <<< "$line"
    # Expand ~ in path
    path="${path/#\~/$HOME}"
    skills="${skills:-all}"

    echo "$name:$path:$skills"
}

status() {
    discover_agents
    echo "=== Skill Hub ==="
    echo "$SKILL_HUB"
    echo ""
    list_skills
    echo ""

    echo "=== Agent Distribution ==="

    [ ! -f "$CONFIG_FILE" ] && echo "(no config file)" && return

    while IFS= read -r line || [ -n "$line" ]; do
        parsed=$(parse_config_line "$line") || continue
        IFS=: read -r name path skills <<< "$parsed"

        echo ""
        echo "$name ($path)"
        if [ "$skills" = "all" ]; then
            echo "  skills: all"
        else
            echo "  skills: $skills"
        fi

        if [ -L "$path" ]; then
            echo "  mode: directory symlink -> $(readlink "$path")"
        elif [ -d "$path" ]; then
            count=$(find "$path" -maxdepth 1 \( -type d -o -type l \) ! -name ".*" ! -name "$(basename "$path")" 2>/dev/null | wc -l | tr -d ' ')
            echo "  mode: individual symlinks ($count skills)"
        else
            echo "  mode: (not set up)"
        fi
    done < "$CONFIG_FILE"
}

sync_agent() {
    local name=$1
    local path=$2
    local skills=$3

    echo "Syncing $name..."

    # Check for local (non-symlinked) skills that might be lost
    local local_skills=()
    if [ -d "$path" ] && [ ! -L "$path" ]; then
        for skill_dir in "$path"/*/; do
            [ -d "$skill_dir" ] || continue
            local skill=$(basename "$skill_dir")
            [[ "$skill" == .* ]] && continue
            if [ ! -L "${skill_dir%/}" ]; then
                local_skills+=("$skill")
            fi
        done

        if [ ${#local_skills[@]} -gt 0 ]; then
            echo "  WARNING: Found ${#local_skills[@]} local skill(s) not managed by skill-hub:"
            for s in "${local_skills[@]}"; do
                echo "    - $s"
            done
            echo ""
            echo "  These may be overwritten or lost. Consider running first:"
            echo "    skill-hub local $name"
            echo "    skill-hub adopt $name <skill>"
            echo ""
            if command -v gum &>/dev/null; then
                if ! gum confirm "Continue with sync anyway?"; then
                    echo "  Sync cancelled."
                    return 1
                fi
            else
                echo -n "  Continue with sync? [y/N] "
                read -r answer
                if [[ ! "$answer" =~ ^[Yy] ]]; then
                    echo "  Sync cancelled."
                    return 1
                fi
            fi
        fi
    fi

    if [ "$skills" = "all" ]; then
        # Full directory symlink mode
        if [ -L "$path" ]; then
            target=$(readlink "$path")
            if [ "$target" = "$SKILL_HUB" ]; then
                echo "  Already symlinked to hub"
                return 0
            else
                echo "  Updating symlink..."
                trash_path "$path" || return 1
            fi
        elif [ -d "$path" ]; then
            echo "  Converting to directory symlink..."
            trash_path "$path" || return 1
        fi

        mkdir -p "$(dirname "$path")"
        ln -s "$SKILL_HUB" "$path"
        echo "  Linked all skills"
    else
        # Individual skill symlinks mode
        if [ -L "$path" ]; then
            echo "  Converting from directory symlink to individual..."
            trash_path "$path" || return 1
        fi

        mkdir -p "$path"

        # Parse comma-separated skills
        IFS=',' read -ra skill_list <<< "$skills"
        for skill in "${skill_list[@]}"; do
            skill=$(echo "$skill" | tr -d ' ')  # trim whitespace
            src="$SKILL_HUB/$skill"
            dst="$path/$skill"

            if [ ! -e "$src" ]; then
                echo "  WARN: $skill not found in hub"
                continue
            fi

            if [ -L "$dst" ]; then
                current=$(readlink "$dst")
                if [ "$current" = "$src" ]; then
                    echo "  $skill: ok"
                    continue
                fi
                trash_path "$dst" || return 1
            elif [ -e "$dst" ]; then
                echo "  WARN: $skill exists locally (not a symlink)"
                echo "        Run 'skill-hub adopt $name $skill' to import it first"
                continue
            fi

            ln -s "$src" "$dst"
            echo "  $skill: linked"
        done
    fi
}

sync_all() {
    local filter=$1

    discover_agents

    [ ! -f "$CONFIG_FILE" ] && echo "No config file at $CONFIG_FILE" && return 1

    while IFS= read -r line || [ -n "$line" ]; do
        parsed=$(parse_config_line "$line") || continue
        IFS=: read -r name path skills <<< "$parsed"

        if [ -z "$filter" ] || [ "$filter" = "$name" ]; then
            sync_agent "$name" "$path" "$skills"
        fi
    done < "$CONFIG_FILE"
}

trash_path() {
    local path=$1

    if [ ! -e "$path" ] && [ ! -L "$path" ]; then
        return 0
    fi

    # Linux: use trash-put if available
    if [[ "$(uname)" == "Linux" ]]; then
        if command -v trash-put &>/dev/null; then
            trash-put "$path"
            return 0
        elif command -v gio &>/dev/null; then
            gio trash "$path"
            return 0
        fi
        # Fallback: create ~/.Trash if needed
        local trash_dir="$HOME/.Trash"
        mkdir -p "$trash_dir"
        local base=$(basename "$path")
        local stamp=$(date +"%Y%m%d-%H%M%S")
        mv "$path" "$trash_dir/${base}.${stamp}.$$"
        return 0
    fi

    # macOS: use ~/.Trash
    local trash_dir="$HOME/.Trash"
    if [ ! -d "$trash_dir" ]; then
        echo "Error: Trash directory not found; cannot remove $path safely."
        return 1
    fi

    local base=$(basename "$path")
    local stamp=$(date +"%Y%m%d-%H%M%S")
    local dest="$trash_dir/${base}.${stamp}.$$"
    mv "$path" "$dest"
}

install_skill_for_agent() {
    local src=$1
    local dst=$2
    local label=$3

    if [ -L "$src" ]; then
        local target=$(readlink "$src")

        if [ -L "$dst" ]; then
            local current=$(readlink "$dst")
            if [ "$current" = "$target" ]; then
                echo "  $label: ok (linked)"
                return 0
            fi
            trash_path "$dst" || return 1
        elif [ -e "$dst" ]; then
            echo "  WARN: $label exists and is not a symlink, skipping"
            return 0
        fi

        ln -s "$target" "$dst"
        echo "  $label: linked -> $target"
        return 0
    fi

    if [ -L "$dst" ]; then
        trash_path "$dst" || return 1
    elif [ -e "$dst" ]; then
        echo "  WARN: $label exists and is not a symlink, skipping"
        return 0
    fi

    cp -R "$src" "$dst"
    echo "  $label: copied"
}

uninstall_agent() {
    local name=$1
    local path=$2
    local skills=$3

    echo "Uninstalling $name..."

    if [ -L "$path" ]; then
        echo "  Detaching directory symlink..."
        trash_path "$path" || return 1
        mkdir -p "$path"
    else
        mkdir -p "$path"
    fi

    local include_system=false
    local skill_list=()

    if [ -z "$skills" ] || [ "$skills" = "all" ]; then
        include_system=true
        while IFS= read -r skill; do
            [ -n "$skill" ] && skill_list+=("$skill")
        done < <(get_all_skills)
    else
        IFS=',' read -ra skill_list <<< "$skills"
    fi

    for skill in "${skill_list[@]}"; do
        skill=$(echo "$skill" | tr -d ' ')
        [ -z "$skill" ] && continue

        local src="$SKILL_HUB/$skill"
        local dst="$path/$skill"

        if [ ! -e "$src" ] && [ ! -L "$src" ]; then
            echo "  WARN: $skill not found in hub"
            continue
        fi

        install_skill_for_agent "$src" "$dst" "$skill" || return 1
    done

    if [ "$include_system" = true ] && [ -d "$SKILL_HUB/.system" ]; then
        install_skill_for_agent "$SKILL_HUB/.system" "$path/.system" ".system" || return 1
    fi
}

uninstall_all() {
    local filter=$1

    discover_agents

    [ ! -f "$CONFIG_FILE" ] && echo "No config file at $CONFIG_FILE" && return 1

    while IFS= read -r line || [ -n "$line" ]; do
        parsed=$(parse_config_line "$line") || continue
        IFS=: read -r name path skills <<< "$parsed"

        if [ -z "$filter" ] || [ "$filter" = "$name" ]; then
            uninstall_agent "$name" "$path" "$skills"
        fi
    done < "$CONFIG_FILE"
}

add_agent() {
    local name=$1
    local path=$2
    local skills=${3:-all}

    mkdir -p "$(dirname "$CONFIG_FILE")"
    touch "$CONFIG_FILE"

    # Remove existing entry
    if grep -q "^$name:" "$CONFIG_FILE" 2>/dev/null; then
        sed -i '' "/^$name:/d" "$CONFIG_FILE"
    fi

    echo "$name:$path:$skills" >> "$CONFIG_FILE"
    echo "Added $name -> $path (skills: $skills)"
    echo "Run 'skill-sync sync $name' to apply"
}

link_project() {
    local skill=$1
    local project_path=$2

    if [ ! -d "$project_path" ]; then
        echo "Error: $project_path does not exist"
        return 1
    fi

    skill_path="$SKILL_HUB/$skill"

    if [ -d "$skill_path" ] && [ ! -L "$skill_path" ]; then
        echo "Backing up existing $skill to $skill.bak"
        mv "$skill_path" "$skill_path.bak"
    fi

    if [ -L "$skill_path" ]; then
        trash_path "$skill_path" || return 1
    fi

    ln -s "$project_path" "$skill_path"
    echo "Linked $skill -> $project_path"
}

# Show detailed info about a skill
skill_info() {
    local skill=$1
    local skill_path="$SKILL_HUB/$skill"

    if [ ! -e "$skill_path" ]; then
        echo "Error: Skill '$skill' not found"
        return 1
    fi

    echo "=== $skill ==="
    echo ""

    # Location info
    if [ -L "$skill_path" ]; then
        local target=$(readlink "$skill_path")
        echo "Type:     project-linked"
        echo "Symlink:  $skill_path"
        echo "Target:   $target"

        # Check if target exists
        if [ ! -e "$target" ]; then
            echo "Status:   BROKEN (target does not exist)"
        else
            echo "Status:   ok"
        fi
    else
        echo "Type:     central"
        echo "Location: $skill_path"
    fi

    # SKILL.md info
    local skill_md="$skill_path/SKILL.md"
    if [ -f "$skill_md" ]; then
        echo ""
        echo "=== SKILL.md ==="
        # Extract frontmatter
        local in_frontmatter=false
        while IFS= read -r line; do
            if [ "$line" = "---" ]; then
                if [ "$in_frontmatter" = true ]; then
                    break
                else
                    in_frontmatter=true
                    continue
                fi
            fi
            if [ "$in_frontmatter" = true ]; then
                echo "  $line"
            fi
        done < "$skill_md"
    fi

    # Show which agents have this skill
    echo ""
    echo "=== Agents ==="
    if [ -f "$CONFIG_FILE" ]; then
        while IFS= read -r line || [ -n "$line" ]; do
            parsed=$(parse_config_line "$line") || continue
            IFS=: read -r name path skills <<< "$parsed"

            local has_skill=false
            if [ "$skills" = "all" ]; then
                has_skill=true
            else
                if echo ",$skills," | grep -q ",$skill,"; then
                    has_skill=true
                fi
            fi

            if [ "$has_skill" = true ]; then
                echo "  $name: enabled"
            else
                echo "  $name: -"
            fi
        done < "$CONFIG_FILE"
    fi
}

# Migrate a skill to its own project repo
migrate_skill() {
    local skill=$1
    local target_path=$2

    local skill_path="$SKILL_HUB/$skill"

    # Verify skill exists
    if [ ! -e "$skill_path" ]; then
        echo "Error: Skill '$skill' not found in hub"
        return 1
    fi

    # Check if already project-linked
    if [ -L "$skill_path" ]; then
        local current_target=$(readlink "$skill_path")
        echo "Skill '$skill' is already project-linked:"
        echo "  $skill_path -> $current_target"
        return 1
    fi

    # Determine target path
    if [ -z "$target_path" ]; then
        local project_dir=$(get_setting "project_dir" "")
        if [ -z "$project_dir" ]; then
            echo "Error: No target path provided and project_dir not configured"
            echo ""
            echo "Either provide a path:"
            echo "  skill-hub migrate $skill ~/p/$skill"
            echo ""
            echo "Or configure the default project directory:"
            echo "  skill-hub config project_dir ~/p"
            return 1
        fi
        target_path="$project_dir/$skill"
    fi

    # Expand ~ if present
    target_path="${target_path/#\~/$HOME}"

    # Check if target already exists
    if [ -e "$target_path" ]; then
        echo "Error: Target path already exists: $target_path"
        echo ""
        echo "If you want to link to an existing repo, use:"
        echo "  skill-hub link-project $skill $target_path/skill"
        return 1
    fi

    echo "Migrating '$skill' to project repo..."
    echo "  From: $skill_path"
    echo "  To:   $target_path"
    echo ""

    # Create target directory and move skill contents directly to it
    mkdir -p "$target_path"
    cp -r "$skill_path"/* "$target_path/"

    # Initialize git if configured
    local git_init=$(get_setting "git_init" "false")
    if [ "$git_init" = "true" ]; then
        echo "Initializing git repo..."
        (
            cd "$target_path"
            git init -q
            git add -A
            git commit -q -m "Initial commit: $skill skill"
        )
        echo "  Created git repo with initial commit"
    fi

    # Remove original and create symlink to repo root
    trash_path "$skill_path" || return 1
    ln -s "$target_path" "$skill_path"

    echo ""
    echo "Migration complete!"
    echo "  Repo:    $target_path"
    echo "  Symlink: $skill_path -> $target_path"
    echo ""
    echo "The skill is now a standalone repo. You can:"
    echo "  cd $target_path"
    if [ "$git_init" = "true" ]; then
        echo "  gh repo create $skill --private --source=. --push"
    else
        echo "  git init && git add -A && git commit -m 'Initial commit'"
    fi
}

# List local (non-symlinked) skills in an agent's workspace
list_local_skills() {
    local agent=$1

    local path=$(get_agent_path "$agent")
    if [ -z "$path" ]; then
        echo "Error: Agent '$agent' not found"
        return 1
    fi

    if [ ! -d "$path" ]; then
        echo "Agent skills directory does not exist: $path"
        return 1
    fi

    echo "Local skills in $agent ($path):"
    echo ""

    local found=0
    for skill_dir in "$path"/*/; do
        [ -d "$skill_dir" ] || continue
        local skill=$(basename "$skill_dir")
        [[ "$skill" == .* ]] && continue

        # Check if it's a symlink
        if [ -L "${skill_dir%/}" ]; then
            continue  # Skip symlinks - they're managed by skill-hub
        fi

        # It's a local directory - candidate for adoption
        found=$((found + 1))
        local has_skill_md=""
        if [ -f "$skill_dir/SKILL.md" ]; then
            has_skill_md="[has SKILL.md]"
        else
            has_skill_md="[no SKILL.md]"
        fi

        # Check if skill already exists in hub
        local in_hub=""
        if [ -d "$SKILL_HUB/$skill" ] || [ -L "$SKILL_HUB/$skill" ]; then
            in_hub="(exists in hub)"
        fi

        printf "  %-25s %s %s\n" "$skill" "$has_skill_md" "$in_hub"
    done

    if [ "$found" -eq 0 ]; then
        echo "  (no local skills found - all are symlinked)"
    else
        echo ""
        echo "Found $found local skill(s). To import into skill-hub:"
        echo "  skill-hub adopt $agent <skill>"
    fi
}

# Adopt a skill from an agent's workspace into skill-hub
adopt_skill() {
    local agent=$1
    local skill=$2

    local agent_path=$(get_agent_path "$agent")
    if [ -z "$agent_path" ]; then
        echo "Error: Agent '$agent' not found"
        return 1
    fi

    local skill_path="$agent_path/$skill"

    # Verify skill exists
    if [ ! -d "$skill_path" ]; then
        echo "Error: Skill '$skill' not found in $agent's workspace"
        echo "  Expected: $skill_path"
        return 1
    fi

    # Check it's not already a symlink
    if [ -L "$skill_path" ]; then
        local target=$(readlink "$skill_path")
        echo "Skill '$skill' is already a symlink:"
        echo "  $skill_path -> $target"
        return 1
    fi

    # Check if SKILL.md exists
    if [ ! -f "$skill_path/SKILL.md" ]; then
        echo "Warning: $skill_path/SKILL.md not found"
        echo "Skills should have a SKILL.md file with frontmatter."
        echo ""
        if command -v gum &>/dev/null; then
            if ! gum confirm "Continue anyway?"; then
                return 1
            fi
        else
            echo -n "Continue anyway? [y/N] "
            read -r answer
            if [[ ! "$answer" =~ ^[Yy] ]]; then
                return 1
            fi
        fi
    fi

    local hub_skill_path="$SKILL_HUB/$skill"

    # Check if skill already exists in hub
    if [ -d "$hub_skill_path" ] || [ -L "$hub_skill_path" ]; then
        echo "Skill '$skill' already exists in skill-hub."
        echo ""
        echo "Options:"
        echo "  1. Replace hub version with agent's version"
        echo "  2. Just symlink agent to existing hub version (discard agent's)"
        echo "  3. Cancel"
        echo ""

        local choice=""
        if command -v gum &>/dev/null; then
            choice=$(gum choose "Replace hub version" "Symlink to hub (discard local)" "Cancel")
        else
            echo -n "Choice [1/2/3]: "
            read -r answer
            case "$answer" in
                1) choice="Replace hub version" ;;
                2) choice="Symlink to hub (discard local)" ;;
                *) choice="Cancel" ;;
            esac
        fi

        case "$choice" in
            "Replace hub version")
                echo "Replacing hub version..."
                trash_path "$hub_skill_path" || return 1
                ;;
            "Symlink to hub (discard local)")
                echo "Replacing local with symlink to hub..."
                trash_path "$skill_path" || return 1
                ln -s "$hub_skill_path" "$skill_path"
                echo "Done: $skill_path -> $hub_skill_path"
                return 0
                ;;
            *)
                echo "Cancelled."
                return 1
                ;;
        esac
    fi

    echo "Adopting '$skill' from $agent into skill-hub..."
    echo "  From: $skill_path"
    echo "  To:   $hub_skill_path"
    echo ""

    # Copy to hub
    cp -r "$skill_path" "$hub_skill_path"

    # Replace local with symlink
    trash_path "$skill_path" || return 1
    ln -s "$hub_skill_path" "$skill_path"

    echo "Adoption complete!"
    echo "  Hub:     $hub_skill_path"
    echo "  Symlink: $skill_path -> $hub_skill_path"
    echo ""

    # Update agent config if needed
    local current_skills=$(get_agent_skills "$agent")
    if [ "$current_skills" != "all" ]; then
        if ! echo ",$current_skills," | grep -q ",$skill,"; then
            echo "Adding '$skill' to $agent's skill list..."
            enable_skill "$agent" "$skill"
        fi
    fi

    echo ""
    echo "The skill is now centrally managed. Other agents can use it with:"
    echo "  skill-hub enable <agent> $skill"
}

#================================================================================
# Dependency Management
#================================================================================

# Extract metadata JSON from SKILL.md
# Only matches metadata: at start of line, outside code blocks
get_skill_metadata() {
    local skill_md="$1"
    # Use awk to skip content inside code blocks
    awk '
        /^```/ { in_code = !in_code; next }
        !in_code && /^metadata:/ { sub(/^metadata: */, ""); print; exit }
    ' "$skill_md" 2>/dev/null || echo "{}"
}

# Parse JSON array using bash (simple parser for our format)
json_array_to_lines() {
    echo "$1" | tr -d '[]"' | tr ',' '\n' | sed 's/^ *//'
}

# Check all skill dependencies
check_deps() {
    local do_install=${1:-false}
    local missing_bins=()
    local missing_env=()
    local install_commands=()
    local has_issues=false

    echo "=== Skill Dependencies ==="
    echo ""

    for skill_dir in "$SKILL_HUB"/*/; do
        [ -d "$skill_dir" ] || continue
        skill=$(basename "$skill_dir")
        [[ "$skill" == .* ]] && continue

        skill_md="$skill_dir/SKILL.md"
        [ ! -f "$skill_md" ] && continue

        # Get metadata
        metadata=$(get_skill_metadata "$skill_md")
        [ "$metadata" = "{}" ] && continue

        # Extract requires.bins using grep/sed (avoiding jq dependency)
        bins=$(echo "$metadata" | grep -oE '"bins":\s*\[[^]]*\]' | sed 's/"bins":\s*//')
        envs=$(echo "$metadata" | grep -oE '"env":\s*\[[^]]*\]' | sed 's/"env":\s*//')

        skill_missing_bins=()
        skill_missing_env=()

        # Check binaries
        if [ -n "$bins" ] && [ "$bins" != "[]" ]; then
            for bin in $(json_array_to_lines "$bins"); do
                [ -z "$bin" ] && continue
                if ! command -v "$bin" &>/dev/null; then
                    skill_missing_bins+=("$bin")
                    # Extract install command for this bin
                    install_info=$(echo "$metadata" | grep -oE '"install":\s*\[[^]]*\]' | sed 's/"install":\s*//')
                fi
            done
        fi

        # Check environment variables
        if [ -n "$envs" ] && [ "$envs" != "[]" ]; then
            for env_var in $(json_array_to_lines "$envs"); do
                [ -z "$env_var" ] && continue
                if [ -z "${!env_var:-}" ]; then
                    skill_missing_env+=("$env_var")
                fi
            done
        fi

        # Report for this skill
        if [ ${#skill_missing_bins[@]} -gt 0 ] || [ ${#skill_missing_env[@]} -gt 0 ]; then
            has_issues=true
            echo "$skill:"
            for bin in "${skill_missing_bins[@]}"; do
                echo "  ✗ bin: $bin"
                missing_bins+=("$bin")
            done
            for env_var in "${skill_missing_env[@]}"; do
                echo "  ✗ env: $env_var"
                missing_env+=("$env_var")
            done
            echo ""
        fi
    done

    # Check for MCP tools referenced in skills
    echo "=== MCP Dependencies ==="
    echo ""

    local mcp_refs=$(grep -rh "mcp__" "$SKILL_HUB"/*/SKILL.md 2>/dev/null | \
        grep -oE 'mcp__[a-zA-Z0-9_-]+__' | sed 's/__$//' | sort -u)

    for mcp in $mcp_refs; do
        mcp_name=$(echo "$mcp" | sed 's/mcp__//')
        echo "  Referenced: $mcp_name"
    done
    echo ""
    echo "  Note: MCP servers must be configured in Claude settings or via plugins"
    echo ""

    # Summary
    echo "=== Summary ==="
    echo ""

    if [ "$has_issues" = false ]; then
        echo "✓ All binary dependencies satisfied"
    else
        echo "Missing binaries: ${missing_bins[*]:-none}"
        echo "Missing env vars: ${missing_env[*]:-none}"
    fi
    echo ""

    # Install if requested
    if [ "$do_install" = true ] && [ ${#missing_bins[@]} -gt 0 ]; then
        echo "=== Installing Dependencies ==="
        echo ""
        install_missing_deps "${missing_bins[@]}"
    elif [ ${#missing_bins[@]} -gt 0 ]; then
        echo "Run 'skill-sync deps install' to install missing dependencies"
    fi
}

install_missing_deps() {
    local bins=("$@")

    for bin in "${bins[@]}"; do
        echo "Installing $bin..."
        case "$bin" in
            op)
                brew install 1password-cli
                ;;
            bird)
                brew install steipete/tap/bird
                ;;
            ynab)
                npm install -g @stephendolan/ynab-cli
                ;;
            mcporter)
                npm install -g mcporter
                ;;
            yt-dlp)
                brew install yt-dlp
                ;;
            ffmpeg)
                brew install ffmpeg
                ;;
            python3)
                brew install python3
                ;;
            *)
                echo "  Unknown package: $bin (try: brew install $bin)"
                ;;
        esac
        echo ""
    done
}

#================================================================================
# Presets System
#================================================================================

preset_create() {
    local name=$1
    local skills=$2

    # Validate skills exist
    local valid_skills=""
    IFS=',' read -ra skill_list <<< "$skills"
    for skill in "${skill_list[@]}"; do
        skill=$(echo "$skill" | tr -d ' ')
        if [ ! -d "$SKILL_HUB/$skill" ]; then
            echo "Warning: Skill '$skill' not found in hub, skipping"
        else
            [ -n "$valid_skills" ] && valid_skills="$valid_skills,"
            valid_skills="$valid_skills$skill"
        fi
    done

    if [ -z "$valid_skills" ]; then
        echo "Error: No valid skills provided"
        return 1
    fi

    mkdir -p "$(dirname "$PRESETS_FILE")"
    touch "$PRESETS_FILE"

    # Remove existing preset with same name
    if grep -q "^$name:" "$PRESETS_FILE" 2>/dev/null; then
        local tmp=$(mktemp)
        grep -v "^$name:" "$PRESETS_FILE" > "$tmp"
        mv "$tmp" "$PRESETS_FILE"
    fi

    echo "$name:$valid_skills" >> "$PRESETS_FILE"
    echo "Created preset '$name' with skills: $valid_skills"
}

preset_list() {
    if [ ! -f "$PRESETS_FILE" ]; then
        echo "No presets defined yet."
        echo "Create one with: skill-hub preset create <name> <skills>"
        return 0
    fi

    echo "Available presets:"
    echo ""
    while IFS=: read -r name skills; do
        [[ "$name" =~ ^[[:space:]]*# ]] && continue
        [ -z "$name" ] && continue
        # Format skills nicely
        local formatted=$(echo "$skills" | tr ',' ', ')
        printf "  ${BOLD}%s${RESET}: %s\n" "$name" "$formatted"
    done < "$PRESETS_FILE"
    echo ""
}

preset_show() {
    local name=$1

    if [ ! -f "$PRESETS_FILE" ]; then
        echo "Error: No presets file found"
        return 1
    fi

    local found=false
    while IFS=: read -r preset_name skills; do
        if [ "$preset_name" = "$name" ]; then
            echo "Preset: $name"
            echo "Skills:"
            IFS=',' read -ra skill_list <<< "$skills"
            for skill in "${skill_list[@]}"; do
                echo "  - $skill"
            done
            found=true
            break
        fi
    done < "$PRESETS_FILE"

    if [ "$found" = false ]; then
        echo "Error: Preset '$name' not found"
        preset_list
        return 1
    fi
}

preset_apply() {
    local agent=$1
    local preset_name=$2

    if [ ! -f "$PRESETS_FILE" ]; then
        echo "Error: No presets file found"
        return 1
    fi

    local skills=""
    while IFS=: read -r name preset_skills; do
        if [ "$name" = "$preset_name" ]; then
            skills="$preset_skills"
            break
        fi
    done < "$PRESETS_FILE"

    if [ -z "$skills" ]; then
        echo "Error: Preset '$preset_name' not found"
        preset_list
        return 1
    fi

    echo "Applying preset '$preset_name' to $agent..."
    set_agent_skills "$agent" "$skills"
}

preset_delete() {
    local name=$1

    if [ ! -f "$PRESETS_FILE" ]; then
        echo "Error: No presets file found"
        return 1
    fi

    if ! grep -q "^$name:" "$PRESETS_FILE"; then
        echo "Error: Preset '$name' not found"
        return 1
    fi

    local tmp=$(mktemp)
    grep -v "^$name:" "$PRESETS_FILE" > "$tmp"
    mv "$tmp" "$PRESETS_FILE"
    echo "Deleted preset '$name'"
}

#================================================================================
# Skill Distribution Management
#================================================================================

# Get current skills for an agent
get_agent_skills() {
    local agent=$1
    discover_agents
    while IFS= read -r line || [ -n "$line" ]; do
        parsed=$(parse_config_line "$line") || continue
        IFS=: read -r name path skills <<< "$parsed"
        if [ "$name" = "$agent" ]; then
            echo "$skills"
            return 0
        fi
    done < "$CONFIG_FILE"
    echo ""
    return 1
}

# Get agent path
get_agent_path() {
    local agent=$1
    discover_agents
    while IFS= read -r line || [ -n "$line" ]; do
        parsed=$(parse_config_line "$line") || continue
        IFS=: read -r name path skills <<< "$parsed"
        if [ "$name" = "$agent" ]; then
            echo "$path"
            return 0
        fi
    done < "$CONFIG_FILE"
    return 1
}

# Set skills for an agent
set_agent_skills() {
    local agent=$1
    local skills=$2

    local path=$(get_agent_path "$agent")
    if [ -z "$path" ]; then
        echo "Error: Agent '$agent' not found in config"
        echo "Available agents:"
        while IFS= read -r line || [ -n "$line" ]; do
            parsed=$(parse_config_line "$line") || continue
            IFS=: read -r name _ _ <<< "$parsed"
            echo "  - $name"
        done < "$CONFIG_FILE"
        return 1
    fi

    # Update config file
    local tmp=$(mktemp)
    while IFS= read -r line || [ -n "$line" ]; do
        if [[ "$line" =~ ^$agent: ]]; then
            echo "$agent:$path:$skills"
        else
            echo "$line"
        fi
    done < "$CONFIG_FILE" > "$tmp"
    mv "$tmp" "$CONFIG_FILE"

    echo "Set $agent skills to: $skills"
    echo ""
    sync_agent "$agent" "$path" "$skills"
}

# Enable a skill for an agent
enable_skill() {
    local agent=$1
    local skill=$2

    # Verify skill exists
    if [ ! -d "$SKILL_HUB/$skill" ]; then
        echo "Error: Skill '$skill' not found in hub"
        echo "Available skills:"
        get_all_skills | sed 's/^/  - /'
        return 1
    fi

    local current=$(get_agent_skills "$agent")
    if [ -z "$current" ]; then
        echo "Error: Agent '$agent' not found"
        return 1
    fi

    if [ "$current" = "all" ]; then
        echo "$agent already has all skills"
        return 0
    fi

    # Check if already enabled
    if echo ",$current," | grep -q ",$skill,"; then
        echo "$skill already enabled for $agent"
        return 0
    fi

    # Add skill
    local new_skills
    if [ -z "$current" ]; then
        new_skills="$skill"
    else
        new_skills="$current,$skill"
    fi

    set_agent_skills "$agent" "$new_skills"
}

# Disable a skill for an agent
disable_skill() {
    local agent=$1
    local skill=$2

    local current=$(get_agent_skills "$agent")
    if [ -z "$current" ]; then
        echo "Error: Agent '$agent' not found"
        return 1
    fi

    if [ "$current" = "all" ]; then
        # Convert "all" to explicit list minus the disabled skill
        local all_skills=$(get_all_skills | tr '\n' ',' | sed 's/,$//')
        current="$all_skills"
    fi

    # Remove skill from list
    local new_skills=$(echo "$current" | tr ',' '\n' | grep -v "^${skill}$" | tr '\n' ',' | sed 's/,$//')

    if [ "$new_skills" = "$current" ]; then
        echo "$skill not found in $agent's skill list"
        return 1
    fi

    if [ -z "$new_skills" ]; then
        echo "Error: Cannot disable last skill. Use 'set' to change configuration."
        return 1
    fi

    set_agent_skills "$agent" "$new_skills"
}

# Copy skills from one agent to another
copy_agent() {
    local from_agent=$1
    local to_agent=$2

    local skills=$(get_agent_skills "$from_agent")
    if [ -z "$skills" ]; then
        echo "Error: Source agent '$from_agent' not found"
        return 1
    fi

    local to_path=$(get_agent_path "$to_agent")
    if [ -z "$to_path" ]; then
        echo "Error: Target agent '$to_agent' not found"
        return 1
    fi

    echo "Copying skills from $from_agent to $to_agent..."
    set_agent_skills "$to_agent" "$skills"
}

# Reset agent to all skills
reset_agent() {
    local agent=$1

    local path=$(get_agent_path "$agent")
    if [ -z "$path" ]; then
        echo "Error: Agent '$agent' not found"
        return 1
    fi

    echo "Resetting $agent to all skills..."
    set_agent_skills "$agent" "all"
}

move_skill_between_agents() {
    local skill=$1
    local from_agent=$2
    local to_agent=$3

    if [ -z "$skill" ] || [ -z "$from_agent" ] || [ -z "$to_agent" ]; then
        echo "Usage: move-skill <skill> <from-agent> <to-agent>"
        return 1
    fi

    if [ ! -d "$SKILL_HUB/$skill" ]; then
        echo "Error: Skill '$skill' not found in hub"
        return 1
    fi

    local from_skills=$(get_agent_skills "$from_agent")
    if [ -z "$from_skills" ]; then
        echo "Error: Agent '$from_agent' not found"
        return 1
    fi

    local to_skills=$(get_agent_skills "$to_agent")
    if [ -z "$to_skills" ]; then
        echo "Error: Agent '$to_agent' not found"
        return 1
    fi

    local from_lines=$(skills_to_lines "$from_skills")
    if ! list_has_line "$from_lines" "$skill"; then
        echo "Error: $skill is not enabled for $from_agent"
        return 1
    fi

    local updated_from=$(remove_skill_from_lines "$from_lines" "$skill")
    if [ -z "$updated_from" ]; then
        echo "Error: Cannot remove last skill from $from_agent"
        return 1
    fi

    local updated_to="$to_skills"
    if [ "$to_skills" != "all" ]; then
        local to_lines=$(skills_to_lines "$to_skills")
        updated_to=$(lines_to_csv "$(add_skill_to_lines "$to_lines" "$skill")")
    fi

    local updated_from_csv=$(lines_to_csv "$updated_from")

    echo "Moving $skill from $from_agent to $to_agent..."
    set_agent_skills "$from_agent" "$updated_from_csv"
    if [ "$to_skills" != "all" ]; then
        set_agent_skills "$to_agent" "$updated_to"
    else
        echo "$to_agent already has all skills; no change needed"
    fi
}

#================================================================================
# Interactive TUI (requires gum)
#================================================================================

interactive() {
    if ! command -v gum &>/dev/null; then
        echo "Error: Interactive mode requires 'gum'"
        echo "Install with: brew install gum"
        return 1
    fi

    discover_agents

    while true; do
        # Build agent list
        local agents=()
        while IFS= read -r line || [ -n "$line" ]; do
            parsed=$(parse_config_line "$line") || continue
            IFS=: read -r name _ _ <<< "$parsed"
            agents+=("$name")
        done < "$CONFIG_FILE"

        # Main menu
        local action=$(gum choose --header "Skill Hub - What would you like to do?" \
            "Configure agent" \
            "Move skill between agents" \
            "Manage skills" \
            "Apply preset" \
            "Create preset" \
            "Exit")

        case "$action" in
            "Manage skills")
                # Build skill list with location info
                local skill_items=()
                for skill_dir in "$SKILL_HUB"/*/; do
                    [ -d "$skill_dir" ] || continue
                    local skill=$(basename "$skill_dir")
                    [[ "$skill" == .* ]] && continue
                    if [ -L "${skill_dir%/}" ]; then
                        skill_items+=("$skill [linked]")
                    else
                        skill_items+=("$skill [central]")
                    fi
                done

                local selected=$(printf '%s\n' "${skill_items[@]}" | gum choose --header "Select a skill:")
                [ -z "$selected" ] && continue

                # Extract skill name (remove [linked] or [central] suffix)
                local skill_name=$(echo "$selected" | sed 's/ \[.*\]$//')
                local skill_path="$SKILL_HUB/$skill_name"

                # Show skill info and actions
                echo ""
                skill_info "$skill_name"
                echo ""

                local skill_action
                if [ -L "$skill_path" ]; then
                    skill_action=$(gum choose --header "What would you like to do with '$skill_name'?" \
                        "Back to menu" \
                        "View in Finder")
                else
                    skill_action=$(gum choose --header "What would you like to do with '$skill_name'?" \
                        "Migrate to project repo" \
                        "Back to menu" \
                        "View in Finder")
                fi

                case "$skill_action" in
                    "Migrate to project repo")
                        local project_dir=$(get_setting "project_dir" "")
                        local default_path=""
                        if [ -n "$project_dir" ]; then
                            default_path="$project_dir/$skill_name"
                        fi

                        local target_path=$(gum input \
                            --placeholder "${default_path:-~/p/$skill_name}" \
                            --value "$default_path" \
                            --header "Target path for $skill_name repo:")

                        if [ -n "$target_path" ]; then
                            echo ""
                            migrate_skill "$skill_name" "$target_path"
                            echo ""
                            gum confirm "Press enter to continue" --affirmative="OK" --negative=""
                        fi
                        ;;
                    "View in Finder")
                        if [ -L "$skill_path" ]; then
                            open "$(readlink "$skill_path")"
                        else
                            open "$skill_path"
                        fi
                        ;;
                    *)
                        ;;
                esac
                ;;
            "Configure agent")
                local agent=$(gum choose --header "Select agent to configure:" "${agents[@]}")
                [ -z "$agent" ] && continue

                while true; do
                    local current=$(get_agent_skills "$agent")
                    local all_skills=$(get_all_skills)
                    local upstream_skills=$(get_upstream_skills "$agent")
                    local current_lines=$(skills_to_lines "$current")
                    local selected_display=$(printf '%s\n%s\n' "$current_lines" "$upstream_skills" | sed '/^$/d' | unique_lines)

                    if [ -z "$all_skills" ]; then
                        echo "No skills found in hub."
                        gum confirm "Press enter to continue" --affirmative="OK" --negative=""
                        break
                    fi

                    local selected_in_order=""
                    local unselected_in_order=""
                    while IFS= read -r skill; do
                        [ -z "$skill" ] && continue
                        if list_has_line "$selected_display" "$skill"; then
                            selected_in_order+="$skill"$'\n'
                        else
                            unselected_in_order+="$skill"$'\n'
                        fi
                    done <<< "$all_skills"

                    local ordered_skills=$(printf '%s%s' "$selected_in_order" "$unselected_in_order" | sed '/^$/d')
                    local selected_count=$(printf '%s' "$selected_in_order" | sed '/^$/d' | wc -l | tr -d ' ')

                    local header="Skills for $agent (TAB to toggle, ENTER to confirm)"
                    if [ -n "$upstream_skills" ]; then
                        header=$'Skills for '"$agent"$' (TAB to toggle, ENTER to confirm)\nUpstream skills are locked and marked \"(upstream -> clawdbot)\".'
                    fi

                    if command -v fzf &>/dev/null; then
                        local list_input=""
                        while IFS= read -r skill; do
                            [ -z "$skill" ] && continue
                            local label="$skill"
                            if list_has_line "$upstream_skills" "$skill"; then
                                label=$'\033[90m'"$skill (upstream -> clawdbot)"$'\033[0m'
                            fi
                            list_input+="${skill}"$'\t'"${label}"$'\n'
                        done <<< "$ordered_skills"

                        local bind=""
                        if [ "$selected_count" -gt 0 ]; then
                            bind="start:toggle"
                            local i=1
                            while [ "$i" -lt "$selected_count" ]; do
                                bind+="+down+toggle"
                                i=$((i + 1))
                            done
                        fi

                        local new_selection=""
                        if [ -n "$bind" ]; then
                            new_selection=$(printf '%s' "$list_input" | fzf --multi --ansi --delimiter $'\t' --with-nth=2 --accept-nth=1 --header "$header" --marker="✓" --pointer="> " --bind "$bind")
                        else
                            new_selection=$(printf '%s' "$list_input" | fzf --multi --ansi --delimiter $'\t' --with-nth=2 --accept-nth=1 --header "$header" --marker="✓" --pointer="> ")
                        fi
                        local choose_status=$?

                        if [ "$choose_status" -ne 0 ]; then
                            local cancel_choice=$(gum choose --header "Cancel changes to $agent?" \
                                "Cancel without saving" \
                                "Continue editing")
                            if [ "$cancel_choice" = "Cancel without saving" ]; then
                                break
                            fi
                            continue
                        fi

                        local selected_lines=$(printf '%s\n' "$new_selection" | sed '/^$/d')
                        if [ -n "$upstream_skills" ]; then
                            selected_lines=$(filter_skills_excluding "$selected_lines" "$upstream_skills")
                        fi

                        if [ -n "$selected_lines" ]; then
                            local new_skills=$(lines_to_csv "$selected_lines")
                            set_agent_skills "$agent" "$new_skills"
                        else
                            local choice
                            if [ -n "$upstream_skills" ]; then
                                choice=$(gum choose --header "No skills selected. What would you like to do?" \
                                    "Enable all selectable skills" \
                                    "Keep current configuration" \
                                    "Cancel")
                                case "$choice" in
                                    "Enable all selectable skills")
                                        local all_selectable=$(filter_skills_excluding "$all_skills" "$upstream_skills")
                                        local all_selectable_csv=$(lines_to_csv "$all_selectable")
                                        set_agent_skills "$agent" "$all_selectable_csv"
                                        ;;
                                    *)
                                        echo "Configuration unchanged."
                                        ;;
                                esac
                            else
                                choice=$(gum choose --header "No skills selected. What would you like to do?" \
                                    "Set to all skills" \
                                    "Keep current configuration" \
                                    "Cancel")
                                case "$choice" in
                                    "Set to all skills")
                                        reset_agent "$agent"
                                        ;;
                                    *)
                                        echo "Configuration unchanged."
                                        ;;
                                esac
                            fi
                        fi
                        break
                    fi

                    # Fallback: gum choose (space to toggle)
                    local gum_header="Skills for $agent (space to toggle, enter to confirm)"
                    if [ -n "$upstream_skills" ]; then
                        gum_header=$'Skills for '"$agent"$' (space to toggle, enter to confirm)\nUpstream skills are locked and marked \"(upstream -> clawdbot)\".'
                    fi

                    local skill_labels=""
                    local selected_labels=""
                    while IFS= read -r skill; do
                        [ -z "$skill" ] && continue
                        local label="$skill"
                        if list_has_line "$upstream_skills" "$skill"; then
                            label=$'\033[90m'"$skill (upstream -> clawdbot)"$'\033[0m'
                        fi
                        skill_labels+="$label"$'\n'
                        if list_has_line "$selected_display" "$skill"; then
                            selected_labels+="$label"$'\n'
                        fi
                    done <<< "$all_skills"

                    local selected_arg=$(lines_to_csv "$selected_labels")
                    local new_selection=$(printf '%s' "$skill_labels" | gum choose --no-limit --selected="$selected_arg" --header "$gum_header" --no-strip-ansi)
                    local choose_status=$?

                    if [ "$choose_status" -ne 0 ]; then
                        local cancel_choice=$(gum choose --header "Cancel changes to $agent?" \
                            "Cancel without saving" \
                            "Continue editing")
                        if [ "$cancel_choice" = "Cancel without saving" ]; then
                            break
                        fi
                        continue
                    fi

                    local selected_lines=""
                    while IFS= read -r label; do
                        [ -z "$label" ] && continue
                        selected_lines+=$(label_to_skill "$label")$'\n'
                    done <<< "$new_selection"
                    selected_lines=$(printf '%s' "$selected_lines" | sed '/^$/d')

                    if [ -n "$upstream_skills" ]; then
                        selected_lines=$(filter_skills_excluding "$selected_lines" "$upstream_skills")
                    fi

                    if [ -n "$selected_lines" ]; then
                        local new_skills=$(lines_to_csv "$selected_lines")
                        set_agent_skills "$agent" "$new_skills"
                    else
                        local choice
                        if [ -n "$upstream_skills" ]; then
                            choice=$(gum choose --header "No skills selected. What would you like to do?" \
                                "Enable all selectable skills" \
                                "Keep current configuration" \
                                "Cancel")
                            case "$choice" in
                                "Enable all selectable skills")
                                    local all_selectable=$(filter_skills_excluding "$all_skills" "$upstream_skills")
                                    local all_selectable_csv=$(lines_to_csv "$all_selectable")
                                    set_agent_skills "$agent" "$all_selectable_csv"
                                    ;;
                                *)
                                    echo "Configuration unchanged."
                                    ;;
                            esac
                        else
                            choice=$(gum choose --header "No skills selected. What would you like to do?" \
                                "Set to all skills" \
                                "Keep current configuration" \
                                "Cancel")
                            case "$choice" in
                                "Set to all skills")
                                    reset_agent "$agent"
                                    ;;
                                *)
                                    echo "Configuration unchanged."
                                    ;;
                            esac
                        fi
                    fi
                    break
                done
                ;;
            "Move skill between agents")
                local from_agent=$(gum choose --header "Move skill from which agent?" "${agents[@]}")
                [ -z "$from_agent" ] && continue
                local to_candidates=()
                local agent_name=""
                for agent_name in "${agents[@]}"; do
                    [ "$agent_name" = "$from_agent" ] && continue
                    to_candidates+=("$agent_name")
                done
                local to_agent=$(gum choose --header "Move skill to which agent?" "${to_candidates[@]}")
                [ -z "$to_agent" ] && continue

                local from_skills=$(get_agent_skills "$from_agent")
                local available_skills=$(skills_to_lines "$from_skills")
                if [ "$from_skills" = "all" ]; then
                    available_skills=$(get_all_skills)
                fi

                if [ -z "$available_skills" ]; then
                    echo "No skills available to move from $from_agent."
                    gum confirm "Press enter to continue" --affirmative="OK" --negative=""
                    continue
                fi

                local skill=$(echo "$available_skills" | gum choose --header "Select a skill to move to $to_agent:")
                [ -z "$skill" ] && continue
                move_skill_between_agents "$skill" "$from_agent" "$to_agent"
                gum confirm "Press enter to continue" --affirmative="OK" --negative=""
                ;;
            "Apply preset")
                if [ ! -f "$PRESETS_FILE" ]; then
                    echo "No presets available. Create one first."
                    gum confirm "Press enter to continue" --affirmative="OK" --negative=""
                    continue
                fi
                local preset=$(cut -d: -f1 "$PRESETS_FILE" | gum choose --header "Select preset:")
                [ -z "$preset" ] && continue
                local agent=$(gum choose --header "Apply '$preset' to which agent?" "${agents[@]}")
                [ -n "$agent" ] && preset_apply "$agent" "$preset"
                ;;
            "Create preset")
                local name=$(gum input --placeholder "Preset name (e.g., research, dev)")
                [ -z "$name" ] && continue
                local all_skills=$(get_all_skills)
                local selected=$(echo "$all_skills" | gum filter --header "Select skills for preset '$name':" --no-limit)
                if [ -n "$selected" ]; then
                    local skills_csv=$(echo "$selected" | tr '\n' ',' | sed 's/,$//')
                    preset_create "$name" "$skills_csv"
                fi
                ;;
            "Exit"|"")
                break
                ;;
        esac
    done
}

# Main
case "${1:-}" in
    init)
        init_skill_hub
        ;;
    new)
        new_skill "$2"
        ;;
    path)
        print_path
        ;;
    status)
        status
        ;;
    i|interactive)
        interactive
        ;;
    list)
        list_skills
        ;;
    info)
        if [ -z "${2:-}" ]; then
            echo "Usage: skill-hub info <skill>"
            exit 1
        fi
        skill_info "$2"
        ;;
    discover)
        discover_agents
        ;;
    sync)
        sync_all "${2:-}"
        ;;
    uninstall)
        uninstall_all "${2:-}"
        ;;
    deps)
        if [ "${2:-}" = "install" ]; then
            check_deps true
        else
            check_deps false
        fi
        ;;
    add-agent)
        if [ -z "${2:-}" ] || [ -z "${3:-}" ]; then
            echo "Usage: skill-hub add-agent <name> <path> [skills]"
            echo "  skills: 'all' (default) or comma-separated list"
            exit 1
        fi
        add_agent "$2" "$3" "${4:-all}"
        ;;
    link-project)
        if [ -z "${2:-}" ] || [ -z "${3:-}" ]; then
            echo "Usage: skill-hub link-project <skill> <project-path>"
            exit 1
        fi
        link_project "$2" "$3"
        ;;
    migrate)
        if [ -z "${2:-}" ]; then
            echo "Usage: skill-hub migrate <skill> [target-path]"
            echo ""
            echo "Moves a skill from central storage to its own project repo."
            echo "If target-path is omitted, uses \$project_dir/<skill> from config."
            exit 1
        fi
        migrate_skill "$2" "${3:-}"
        ;;
    local)
        if [ -z "${2:-}" ]; then
            echo "Usage: skill-hub local <agent>"
            echo ""
            echo "Lists local (non-symlinked) skills in an agent's workspace."
            echo "These are candidates for adoption into skill-hub."
            exit 1
        fi
        list_local_skills "$2"
        ;;
    adopt)
        if [ -z "${2:-}" ] || [ -z "${3:-}" ]; then
            echo "Usage: skill-hub adopt <agent> <skill>"
            echo ""
            echo "Imports a skill from an agent's workspace into skill-hub."
            echo "The local copy is replaced with a symlink to the hub."
            echo ""
            echo "To see adoptable skills: skill-hub local <agent>"
            exit 1
        fi
        adopt_skill "$2" "$3"
        ;;
    config)
        config_cmd "${2:-}" "${3:-}"
        ;;
    set)
        if [ -z "${2:-}" ] || [ -z "${3:-}" ]; then
            echo "Usage: skill-hub set <agent> <skills>"
            echo "  skills: 'all' or comma-separated list (e.g., 'bird,ynab,spreadsheet')"
            exit 1
        fi
        set_agent_skills "$2" "$3"
        ;;
    enable)
        if [ -z "${2:-}" ] || [ -z "${3:-}" ]; then
            echo "Usage: skill-hub enable <agent> <skill>"
            exit 1
        fi
        enable_skill "$2" "$3"
        ;;
    disable)
        if [ -z "${2:-}" ] || [ -z "${3:-}" ]; then
            echo "Usage: skill-hub disable <agent> <skill>"
            exit 1
        fi
        disable_skill "$2" "$3"
        ;;
    copy)
        if [ -z "${2:-}" ] || [ -z "${3:-}" ]; then
            echo "Usage: skill-hub copy <from-agent> <to-agent>"
            exit 1
        fi
        copy_agent "$2" "$3"
        ;;
    move-skill)
        if [ -z "${2:-}" ] || [ -z "${3:-}" ] || [ -z "${4:-}" ]; then
            echo "Usage: skill-hub move-skill <skill> <from-agent> <to-agent>"
            exit 1
        fi
        move_skill_between_agents "$2" "$3" "$4"
        ;;
    reset)
        if [ -z "${2:-}" ]; then
            echo "Usage: skill-hub reset <agent>"
            exit 1
        fi
        reset_agent "$2"
        ;;
    preset)
        case "${2:-}" in
            create)
                if [ -z "${3:-}" ] || [ -z "${4:-}" ]; then
                    echo "Usage: skill-hub preset create <name> <skills>"
                    echo "  skills: comma-separated list (e.g., 'perplexity,deep-research')"
                    exit 1
                fi
                preset_create "$3" "$4"
                ;;
            list)
                preset_list
                ;;
            show)
                if [ -z "${3:-}" ]; then
                    echo "Usage: skill-hub preset show <name>"
                    exit 1
                fi
                preset_show "$3"
                ;;
            apply)
                if [ -z "${3:-}" ] || [ -z "${4:-}" ]; then
                    echo "Usage: skill-hub preset apply <agent> <preset>"
                    exit 1
                fi
                preset_apply "$3" "$4"
                ;;
            delete)
                if [ -z "${3:-}" ]; then
                    echo "Usage: skill-hub preset delete <name>"
                    exit 1
                fi
                preset_delete "$3"
                ;;
            *)
                echo "Usage: skill-hub preset <create|list|show|apply|delete> [args]"
                exit 1
                ;;
        esac
        ;;
    -h|--help|help)
        usage
        ;;
    "")
        # No command - launch interactive mode
        interactive
        ;;
    *)
        echo "Unknown command: $1"
        echo ""
        usage
        exit 1
        ;;
esac
